// VirtualBookShelfService contÃ©m a lÃ³gica de negÃ³cio para ordenaÃ§Ã£o dos livros na estante virtual
// Nova lÃ³gica: Admin define cÃ³digo INICIAL de cada prateleira, cÃ³digo final Ã© calculado automaticamente
// PadrÃ£o de logs:
// ðŸ”µ InÃ­cio de operaÃ§Ã£o
// ðŸŸ¢ Sucesso
// ðŸŸ¡ Aviso/Fluxo alternativo
// ðŸ”´ Erro

const VirtualBookShelfModel = require('../models/VirtualBookShelfModel');
const BooksModel = require('../models/BooksModel');

/**
 * Service responsÃ¡vel pela lÃ³gica de ordenaÃ§Ã£o da estante virtual
 */
class VirtualBookShelfService {

    /**
     * Ordem das Ã¡reas para classificaÃ§Ã£o
     */
    static AREA_ORDER = ['BIO', 'QUI', 'FIS', 'MAT', 'CMP', 'VAR'];

    /**
     * Mapeamento de nomes de Ã¡rea para cÃ³digos
     */
    static AREA_NAME_TO_CODE = {
        'Biologia': 'BIO',
        'QuÃ­mica': 'QUI', 
        'FÃ­sica': 'FIS',
        'MatemÃ¡tica': 'MAT',
        'ComputaÃ§Ã£o': 'CMP',
        'Variados': 'VAR'
    };

    /**
     * ObtÃ©m todas as configuraÃ§Ãµes de prateleiras com cÃ³digos finais calculados
     */
    async getShelvesConfig() {
        console.log("ðŸ”µ [VirtualBookShelfService] Obtendo configuraÃ§Ãµes das prateleiras");
        try {
            const shelves = await VirtualBookShelfModel.getAllShelves();
            // Calcula e atualiza cÃ³digos finais automaticamente
            const shelvesWithCalculatedEnds = await this.calculateEndCodes(shelves);
            console.log(`ðŸŸ¢ [VirtualBookShelfService] ConfiguraÃ§Ãµes obtidas: ${shelves.length}`);
            return shelvesWithCalculatedEnds;
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao obter configuraÃ§Ãµes:", error.message);
            throw error;
        }
    }

    /**
     * Calcula automaticamente os cÃ³digos finais baseado nos cÃ³digos iniciais
     */
    async calculateEndCodes(shelves) {
        console.log("ðŸ”µ [VirtualBookShelfService] Calculando cÃ³digos finais das prateleiras");
        
        // Ordena prateleiras por estante e depois por prateleira
        const sortedShelves = shelves.sort((a, b) => {
            if (a.shelf_number !== b.shelf_number) {
                return a.shelf_number - b.shelf_number;
            }
            return a.shelf_row - b.shelf_row;
        });

        const result = [];
        
        for (let i = 0; i < sortedShelves.length; i++) {
            const currentShelf = { ...sortedShelves[i] };
            
            if (!currentShelf.book_code_start) {
                // Se nÃ£o tem cÃ³digo inicial, nÃ£o pode calcular final
                currentShelf.calculated_book_code_end = null;
                result.push(currentShelf);
                continue;
            }

            // Encontra a prÃ³xima prateleira com cÃ³digo inicial definido
            let nextShelfWithCode = null;
            for (let j = i + 1; j < sortedShelves.length; j++) {
                if (sortedShelves[j].book_code_start) {
                    nextShelfWithCode = sortedShelves[j];
                    break;
                }
            }

            if (nextShelfWithCode) {
                // O cÃ³digo final Ã© um antes do cÃ³digo inicial da prÃ³xima prateleira
                currentShelf.calculated_book_code_end = this.getPreviousCode(nextShelfWithCode.book_code_start);
            } else {
                // Ã‰ a Ãºltima prateleira com cÃ³digo definido
                // Usa o book_code_end se foi definido manualmente, senÃ£o deixa null
                currentShelf.calculated_book_code_end = currentShelf.book_code_end || null;
            }

            result.push(currentShelf);
        }

        console.log("ðŸŸ¢ [VirtualBookShelfService] CÃ³digos finais calculados");
        return result;
    }

    /**
     * Calcula o cÃ³digo anterior a um dado cÃ³digo
     * Ex: "BIO-03.05-v1" -> "BIO-03.04-v1"
     * Ex: "BIO-03.01-v1" -> "BIO-02.99-v1"
     */
    getPreviousCode(code) {
        try {
            if (!code) return null;

            const parsed = this.parseBookCode(code);
            
            if (parsed.sequential > 1) {
                // Decrementa o sequencial
                const previousSeq = (parsed.sequential - 1).toString().padStart(2, '0');
                const volumePart = parsed.volume > 0 ? `-v${parsed.volume}` : '';
                return `${parsed.area}-${parsed.subarea.toString().padStart(2, '0')}.${previousSeq}${volumePart}`;
            } else if (parsed.subarea > 1) {
                // Se sequencial Ã© 1, vai para subÃ¡rea anterior com sequencial 99
                const previousSubarea = (parsed.subarea - 1).toString().padStart(2, '0');
                const volumePart = parsed.volume > 0 ? `-v${parsed.volume}` : '';
                return `${parsed.area}-${previousSubarea}.99${volumePart}`;
            } else {
                // Se tambÃ©m Ã© subÃ¡rea 1, vai para Ã¡rea anterior
                const areaIndex = VirtualBookShelfService.AREA_ORDER.indexOf(parsed.area);
                if (areaIndex > 0) {
                    const previousArea = VirtualBookShelfService.AREA_ORDER[areaIndex - 1];
                    const volumePart = parsed.volume > 0 ? `-v${parsed.volume}` : '';
                    return `${previousArea}-99.99${volumePart}`;
                }
            }

            return null;
        } catch (error) {
            console.warn(`ðŸŸ¡ [VirtualBookShelfService] Erro ao calcular cÃ³digo anterior para ${code}:`, error.message);
            return null;
        }
    }

    /**
     * Atualiza configuraÃ§Ãµes das prateleiras
     */
    async updateShelvesConfig(shelvesConfig) {
        console.log("ðŸ”µ [VirtualBookShelfService] Atualizando configuraÃ§Ãµes das prateleiras");
        try {
            await VirtualBookShelfModel.updateShelvesConfig(shelvesConfig);
            console.log("ðŸŸ¢ [VirtualBookShelfService] ConfiguraÃ§Ãµes atualizadas com sucesso");
            return { success: true };
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao atualizar configuraÃ§Ãµes:", error.message);
            throw error;
        }
    }

    /**
     * Atualiza o cÃ³digo inicial de uma prateleira especÃ­fica
     */
    async updateShelfStartCode(shelf_number, shelf_row, book_code_start) {
        console.log(`ðŸ”µ [VirtualBookShelfService] Atualizando cÃ³digo inicial da prateleira ${shelf_number}-${shelf_row}`);
        try {
            // Valida o cÃ³digo do livro antes de salvar
            if (book_code_start) {
                const validation = await this.validateBookCode(book_code_start);
                if (!validation.isValid) {
                    throw new Error(`CÃ³digo de livro invÃ¡lido: ${book_code_start}`);
                }
            }

            await VirtualBookShelfModel.updateShelfStartCode(shelf_number, shelf_row, book_code_start);
            console.log("ðŸŸ¢ [VirtualBookShelfService] CÃ³digo inicial atualizado com sucesso");
            return { success: true };
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao atualizar cÃ³digo inicial:", error.message);
            throw error;
        }
    }

    /**
     * Atualiza o cÃ³digo final de uma prateleira especÃ­fica (apenas para Ãºltima prateleira)
     */
    async updateShelfEndCode(shelf_number, shelf_row, book_code_end) {
        console.log(`ðŸ”µ [VirtualBookShelfService] Atualizando cÃ³digo final da prateleira ${shelf_number}-${shelf_row}`);
        try {
            // Valida o cÃ³digo do livro antes de salvar
            if (book_code_end) {
                const validation = await this.validateBookCode(book_code_end);
                if (!validation.isValid) {
                    throw new Error(`CÃ³digo de livro invÃ¡lido: ${book_code_end}`);
                }
            }

            await VirtualBookShelfModel.updateShelfEndCode(shelf_number, shelf_row, book_code_end);
            console.log("ðŸŸ¢ [VirtualBookShelfService] CÃ³digo final atualizado com sucesso");
            return { success: true };
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao atualizar cÃ³digo final:", error.message);
            throw error;
        }
    }

    /**
     * ObtÃ©m todos os livros ordenados conforme a lÃ³gica da estante virtual
     */
    async getAllBooksOrdered() {
        console.log("ðŸ”µ [VirtualBookShelfService] Ordenando todos os livros para estante virtual");
        try {
            const books = await BooksModel.getAll();
            const borrowed = await BooksModel.getBorrowedBooks();
            // Garante que book_id e id sÃ£o do mesmo tipo (number)
            const borrowedSet = new Set(
                borrowed.map(b => Number(b.book_id))
            );
            // Adiciona o status disponÃ­vel a cada livro e converte area para cÃ³digo
            const booksWithAvailability = books.map(book => ({
                ...book,
                area: VirtualBookShelfService.AREA_NAME_TO_CODE[book.area] || book.area,
                available: !borrowedSet.has(Number(book.id))
            }));
            const orderedBooks = this.sortBooks(booksWithAvailability);
            console.log(`ðŸŸ¢ [VirtualBookShelfService] Livros ordenados: ${orderedBooks.length}`);
            return orderedBooks;
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao ordenar livros:", error.message);
            throw error;
        }
    }

    /**
     * Ordena os livros seguindo a lÃ³gica:
     * 1. Por Ã¡rea (BIO, QUI, FIS, MAT, CMP, VAR)
     * 2. Por subÃ¡rea (numerical ascending)
     * 3. Por sequencial (ascending within subarea)
     * 4. Por volume (v1, v2, v3...)
     */
    sortBooks(books) {
        console.log("ðŸ”µ [VirtualBookShelfService] Aplicando ordenaÃ§Ã£o customizada dos livros");
        
        return books.sort((a, b) => {
            return this.compareBookCodes(a.code, b.code);
        });
    }

    /**
     * Compara dois cÃ³digos de livros no formato BIO-03.02-v1
     * Retorna -1 se a < b, 1 se a > b, 0 se iguais
     */
    compareBookCodes(codeA, codeB) {
        const parsedA = this.parseBookCode(codeA);
        const parsedB = this.parseBookCode(codeB);
        
        // 1. Comparar por Ã¡rea
        const areaIndexA = VirtualBookShelfService.AREA_ORDER.indexOf(parsedA.area);
        const areaIndexB = VirtualBookShelfService.AREA_ORDER.indexOf(parsedB.area);
        
        if (areaIndexA !== areaIndexB) {
            return areaIndexA - areaIndexB;
        }

        // 2. Comparar por subÃ¡rea
        if (parsedA.subarea !== parsedB.subarea) {
            return parsedA.subarea - parsedB.subarea;
        }

        // 3. Comparar por sequencial
        if (parsedA.sequential !== parsedB.sequential) {
            return parsedA.sequential - parsedB.sequential;
        }

        // 4. Comparar por volume
        return parsedA.volume - parsedB.volume;
    }

    /**
     * Converte um cÃ³digo de livro em suas partes componentes
     * Ex: "BIO-03.02-v1" -> {area: "BIO", subarea: 3, sequential: 2, volume: 1}
     */
    parseBookCode(code) {
        try {
            if (!code) {
                return { area: '', subarea: 0, sequential: 0, volume: 0 };
            }

            // Dividir por volume: "BIO-03.02-v1" -> ["BIO-03.02", "v1"]
            const parts = code.split('-v');
            const mainPart = parts[0]; // "BIO-03.02"
            const volumePart = parts[1]; // "1" (ou undefined)

            // Extrair Ã¡rea e subÃ¡rea.sequencial: "BIO-03.02" -> ["BIO", "03.02"]
            const mainParts = mainPart.split('-');
            if (mainParts.length < 2) {
                return { area: mainPart, subarea: 0, sequential: 0, volume: 0 };
            }

            const area = mainParts[0]; // "BIO"
            const subareaSeq = mainParts[1]; // "03.02"

            // Dividir subÃ¡rea e sequencial: "03.02" -> ["03", "02"]
            const subareaSeqParts = subareaSeq.split('.');
            const subarea = parseInt(subareaSeqParts[0], 10) || 0; // 3
            const sequential = parseInt(subareaSeqParts[1], 10) || 0; // 2

            // Extrair volume
            const volume = volumePart ? parseInt(volumePart, 10) || 0 : 0; // 1

            return { area, subarea, sequential, volume };
        } catch (error) {
            console.warn(`ðŸŸ¡ [VirtualBookShelfService] Erro ao parsear cÃ³digo ${code}:`, error.message);
            return { area: '', subarea: 0, sequential: 0, volume: 0 };
        }
    }

    /**
     * ObtÃ©m livros para uma prateleira especÃ­fica baseado nas configuraÃ§Ãµes
     */
    async getBooksForShelf(shelf, allShelves, allBooks = null) {
        console.log(`ðŸ”µ [VirtualBookShelfService] Obtendo livros para prateleira ${shelf.shelf_number}-${shelf.shelf_row}`);
        
        try {
            // Se nÃ£o forneceu os livros, busca todos
            if (!allBooks) {
                allBooks = await this.getAllBooksOrdered();
            }

            if (!shelf.book_code_start) {
                console.log("ðŸŸ¡ [VirtualBookShelfService] Prateleira sem cÃ³digo inicial definido");
                return [];
            }

            // Calcula cÃ³digos finais se necessÃ¡rio
            const shelvesWithEndCodes = await this.calculateEndCodes(allShelves);
            const currentShelfWithEndCode = shelvesWithEndCodes.find(s => 
                s.shelf_number === shelf.shelf_number && s.shelf_row === shelf.shelf_row
            );

            if (!currentShelfWithEndCode || !currentShelfWithEndCode.calculated_book_code_end) {
                console.log("ðŸŸ¡ [VirtualBookShelfService] NÃ£o foi possÃ­vel calcular cÃ³digo final para esta prateleira");
                return [];
            }

            const startCode = shelf.book_code_start;
            const endCode = currentShelfWithEndCode.calculated_book_code_end;

            // Filtra livros que pertencem a esta prateleira usando comparaÃ§Ã£o correta de cÃ³digos
            const booksForShelf = allBooks.filter(book => {
                return this.isCodeInRange(book.code, startCode, endCode);
            });

            console.log(`ðŸŸ¢ [VirtualBookShelfService] Livros encontrados para prateleira: ${booksForShelf.length}`);
            return booksForShelf;

        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao obter livros da prateleira:", error.message);
            throw error;
        }
    }

    /**
     * Verifica se um cÃ³digo estÃ¡ dentro do range especificado
     * Usa comparaÃ§Ã£o correta considerando a estrutura BIO-03.02-v1
     */
    isCodeInRange(bookCode, startCode, endCode) {
        const compareWithStart = this.compareBookCodes(bookCode, startCode);
        const compareWithEnd = this.compareBookCodes(bookCode, endCode);
        
        // bookCode >= startCode && bookCode <= endCode
        return compareWithStart >= 0 && compareWithEnd <= 0;
    }

    /**
     * Valida se um cÃ³digo de livro existe
     */
    async validateBookCode(bookCode) {
        console.log(`ðŸ”µ [VirtualBookShelfService] Validando cÃ³digo de livro: ${bookCode}`);
        try {
            const books = await BooksModel.getAll();
            const book = books.find(b => b.code === bookCode);
            
            const isValid = !!book;
            console.log(`ðŸŸ¢ [VirtualBookShelfService] CÃ³digo ${bookCode} Ã© ${isValid ? 'vÃ¡lido' : 'invÃ¡lido'}`);
            return { isValid, book };
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao validar cÃ³digo:", error.message);
            throw error;
        }
    }

    /**
     * Marca uma prateleira como Ãºltima da estante
     */
    async setLastShelf(shelf_number, shelf_row, is_last_shelf) {
        console.log(`ðŸ”µ [VirtualBookShelfService] Configurando prateleira ${shelf_number}-${shelf_row} como Ãºltima: ${is_last_shelf}`);
        try {
            await VirtualBookShelfModel.setLastShelf(shelf_number, shelf_row, is_last_shelf);
            console.log("ðŸŸ¢ [VirtualBookShelfService] ConfiguraÃ§Ã£o de Ãºltima prateleira atualizada");
            return { success: true };
        } catch (error) {
            console.error("ðŸ”´ [VirtualBookShelfService] Erro ao configurar Ãºltima prateleira:", error.message);
            throw error;
        }
    }
}

module.exports = new VirtualBookShelfService();